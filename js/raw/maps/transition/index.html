<!DOCTYPE html>
<meta charset="utf-8">
<title>Map Projection Transitions</title>
<style>
@import url(../maps.css);
#map { cursor: move; }
</style>

<p class="breadcrumbs"><a href="http://www.jasondavies.com/">Jason Davies</a> → <a href="../">Maps</a>

<h1>Map Projection Transitions</h1>

<div id="map"></div>

<p><select id="projection-menu"></select>
<button id="pause">Pause</button>

<div class="wrapper">
  <p>By default, <a href="http://github.com/mbostock/d3/wiki/Geo-Projections">d3.geo</a> will cut lines and polygons where they cross the <a href="http://en.wikipedia.org/wiki/180th_meridian">antimeridian</a>.
  This is usually appropriate for conic and cylindrical projections.
  <p>Projections with the same type of clipping are simple to transition using a weighted average of the source and target projections.
  <p>Based on <a href="http://bl.ocks.org/3711652">Projection Transitions</a> by Mike Bostock.
</div>

<script src="../../d3.min.js?resample-min"></script>
<script src="../d3.geo.projection.min.js?f1a188c7"></script>
<script src="../topojson.min.js?1.0.0"></script>
<script>

var ratio = window.devicePixelRatio || 1,
    width = 960 * ratio,
    height = 500 * ratio;

var options = [
  {name: "Aitoff", projection: d3.geo.aitoff()},
  //{name: "Albers", projection: d3.geo.albers().scale(145).parallels([20, 50])},
  {name: "August", projection: d3.geo.august().scale(60)},
  {name: "Baker", projection: d3.geo.baker().scale(100)},
  {name: "Boggs", projection: d3.geo.boggs()},
  {name: "Bonne", projection: d3.geo.bonne().scale(100)},
  {name: "Bromley", projection: d3.geo.bromley()},
  {name: "Collignon", projection: d3.geo.collignon().scale(93)},
  {name: "Craster Parabolic", projection: d3.geo.craster()},
  {name: "Eckert I", projection: d3.geo.eckert1().scale(165)},
  {name: "Eckert II", projection: d3.geo.eckert2().scale(165)},
  {name: "Eckert III", projection: d3.geo.eckert3().scale(180)},
  {name: "Eckert IV", projection: d3.geo.eckert4().scale(180)},
  {name: "Eckert V", projection: d3.geo.eckert5().scale(170)},
  {name: "Eckert VI", projection: d3.geo.eckert6().scale(170)},
  {name: "Eisenlohr", projection: d3.geo.eisenlohr().scale(60)},
  {name: "Equirectangular (Plate Carrée)", projection: d3.geo.equirectangular()},
  {name: "Fahey", projection: d3.geo.fahey().scale(120)},
  {name: "Gall Stereographic", projection: d3.geo.cylindricalStereographic().parallel(45).scale(140)},
  {name: "Goode Homolosine", projection: d3.geo.homolosine()},
  {name: "Ginzburg IV", projection: d3.geo.ginzburg4().scale(120)},
  {name: "Ginzburg V", projection: d3.geo.ginzburg5().scale(120)},
  {name: "Ginzburg VI", projection: d3.geo.ginzburg6().scale(120)},
  {name: "Ginzburg VIII", projection: d3.geo.ginzburg8().scale(120)},
  {name: "Ginzburg IX", projection: d3.geo.ginzburg9().scale(120)},
  {name: "Gringorten", projection: d3.geo.gringorten().scale(220)},
  {name: "Guyou", projection: d3.geo.guyou().scale(150)},
  {name: "Hammer", projection: d3.geo.hammer().scale(165)},
  {name: "Hill", projection: d3.geo.hill().scale(120)},
  {name: "Kavrayskiy VII", projection: d3.geo.kavrayskiy7()},
  {name: "Lagrange", projection: d3.geo.lagrange().scale(120)},
  {name: "Lambert cylindrical equal-area", projection: d3.geo.cylindricalEqualArea()},
  {name: "Larrivée", projection: d3.geo.larrivee().scale(95)},
  {name: "Laskowski", projection: d3.geo.laskowski().scale(120)},
  {name: "Loximuthal", projection: d3.geo.loximuthal()},
  {name: "Mercator", projection: d3.geo.mercator().scale(100)},
  {name: "Miller", projection: d3.geo.miller().scale(100)},
  {name: "McBryde–Thomas Flat-Polar Parabolic", projection: d3.geo.mtFlatPolarParabolic()},
  {name: "McBryde–Thomas Flat-Polar Quartic", projection: d3.geo.mtFlatPolarQuartic()},
  {name: "McBryde–Thomas Flat-Polar Sinusoidal", projection: d3.geo.mtFlatPolarSinusoidal()},
  {name: "Mollweide", projection: d3.geo.mollweide().scale(165)},
  {name: "Natural Earth", projection: d3.geo.naturalEarth()},
  {name: "Nell–Hammer", projection: d3.geo.nellHammer()},
  {name: "Polyconic", projection: d3.geo.polyconic().scale(100)},
  {name: "Rectangular Polyconic", projection: d3.geo.rectangularPolyconic().scale(120)},
  {name: "Robinson", projection: d3.geo.robinson()},
  {name: "Sinusoidal", projection: d3.geo.sinusoidal()},
  {name: "Sinu-Mollweide", projection: d3.geo.sinuMollweide()},
  {name: "Times", projection: d3.geo.times().scale(140)},
  {name: "Van der Grinten", projection: d3.geo.vanDerGrinten().scale(75)},
  {name: "Van der Grinten II", projection: d3.geo.vanDerGrinten2().scale(75)},
  {name: "Van der Grinten III", projection: d3.geo.vanDerGrinten3().scale(75)},
  {name: "Van der Grinten IV", projection: d3.geo.vanDerGrinten4().scale(120)},
  {name: "Wagner IV", projection: d3.geo.wagner4()},
  {name: "Wagner VI", projection: d3.geo.wagner6()},
  {name: "Wagner VII", projection: d3.geo.wagner7()},
  {name: "Winkel Tripel", projection: d3.geo.winkel3()}
];

var initial = [-71, 42, 0],
    rotate = initial.slice(),
    pause = 0,
    velocity = [.010, -.002],
    t0 = Date.now();

var interval = setInterval(loop, 5000),
    i = 0,
    n = options.length - 1;

var projection = options[i].projection;

options.forEach(function(option) {
  option.projection
      .translate([width / 2, height / 2])
      .scale(option.projection.scale() * ratio)
      .clipExtent([[2 * ratio, 2 * ratio], [width - 2 * ratio, height - 2 * ratio]]);
});

d3.select("#pause").on("click", function() {
  if (!(pause ^= 4)) {
    t0 = Date.now();
    initial = rotate.slice();
  }
});

var graticule = d3.geo.graticule()(),
    land,
    boundaries;

var canvas = d3.select("#map").append("canvas")
    .attr("width", width)
    .attr("height", height)
    .style("width", width / ratio + "px")
    .style("height", height / ratio + "px")
    .call(d3.behavior.drag()
      .origin(function() { return {x: rotate[0], y: -rotate[1]}; })
      .on("dragstart", function() { pause |= 1; })
      .on("drag", function(d) {
        rotate[0] = d3.event.x;
        rotate[1] = -d3.event.y;
        projection.rotate(rotate);
        redraw(path);
      })
      .on("dragend", function() {
        pause &= ~1;
        t0 = Date.now();
        initial = rotate.slice();
      }));

var context = canvas.node().getContext("2d");
context.fillStyle = "#f9f9f9";
context.strokeStyle = "#000";

var path = d3.geo.path()
    .projection(projection)
    .context(context);

var menu = d3.select("#projection-menu")
    .on("change", change);

menu.selectAll("option")
    .data(options)
  .enter().append("option")
    .text(function(d) { return d.name; });

function loop() {
  if (pause) return;
  var j = Math.floor(Math.random() * n);
  menu.property("selectedIndex", i = j + (j >= i));
  update(options[i]);
}

function change() {
  clearInterval(interval);
  update(options[this.selectedIndex]);
}

function pathTween(projection0, projection1, rotate) {
  projection0.rotate([0, 0, 0]);
  projection1.rotate([0, 0, 0]);
  var t = 0,
      projection = d3.geo.projection(function(λ, φ) {
          λ *= 180 / Math.PI, φ *= 180 / Math.PI;
          var p0 = projection0([λ, φ]), p1 = projection1([λ, φ]);
          return [(1 - t) * p0[0] + t * p1[0], (1 - t) * -p0[1] + t * -p1[1]];
        })
        .rotate(rotate)
        .scale(1)
        .translate([width / 2, height / 2])
        .clipExtent(projection0.clipExtent()),
      path = d3.geo.path().projection(projection).context(context);
  return function() {
    return function(u) {
      t = u;
      redraw(path);
    };
  };
}

function update(option) {
  pause |= 2;
  canvas.transition()
      .duration(750)
      .tween("path", pathTween(projection, projection = option.projection, initial = rotate.slice()))
      .each("end", function() {
        pause &= ~2;
        t0 = Date.now();
      });
  path.projection(projection);
}

d3.timer(function() {
  if (pause) return;
  var t = Date.now() - t0;
  rotate[0] = initial[0] + velocity[0] * t;
  rotate[1] = initial[1] + velocity[1] * t;
  projection.rotate(rotate);
  redraw(path);
});

function redraw(path) {
  context.clearRect(0, 0, width, height);
  context.lineWidth = .5 * ratio;
  if (land) {
    context.strokeStyle = "#000";
    context.beginPath(), path(land), context.fill(), context.stroke();
    context.beginPath(), path(boundaries), context.stroke();
  }
  context.strokeStyle = "#999";
  context.beginPath(), path(graticule), context.stroke();
  context.lineWidth = 2.5 * ratio, context.strokeStyle = "#000";
  context.beginPath(), path({type: "Sphere"}), context.stroke();
}

d3.json("../world-110m.json", function(error, world) {
  land = topojson.feature(world, world.objects.land);
  boundaries = topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; });
});

</script>
