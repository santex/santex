<!DOCTYPE html>
<meta charset="utf-8">
<title>Line Simplification</title>
<style>
@import url(../style.css);

body {
  width: 720px;
}

path, line {
  stroke: #000;
  fill: none;
}
.simplify {
  width: 360px;
  height: 550px;
  float: left;
}
.simplify p {
  width: 300px;
  font-size: small;
}
.simplify g:hover circle {
  stroke-width: 1.5px;
}
.simplify text {
  pointer-events: none;
}
circle {
  stroke: #000;
  fill: #fff;
}
text {
  font: 10px sans-serif;
}

#map path {
  stroke-linejoin: round;
}

#controls {
  font-family: sans-serif;
  font-size: small;
  color: #666;
  background: rgba(255,255,255,.8);
}

.intersections {
  stroke: #f00;
  stroke-width: 10.5px;
  stroke-linecap: round;
  stroke-opacity: .5;
  fill: none;
}

#pseudocode {
  clear: both;
}

code {
  line-height: 1em;
  font-family: "Menlo", monospace;
}

.javascript .string,
.javascript .regexp {
  color: #756bb1;
}

.javascript .keyword {
  color: #3182bd;
}

.comment {
  color: #939393;
}

.javascript .number {
  color: #31a354;
}

.javascript .class,
.javascript .special {
  color: #e6550d;
}

.modified {
  background: #ffd;
}

#map {
  position: relative;
  overflow: hidden;
}

#controls {
  position: absolute;
  top: 0;
  left: 0;
  width: 300px;
}

#controls input {
  vertical-align: middle;
}

#controls p {
  width: auto;
}

p.cite {
  text-align: right;
  font-size: small;
  font-style: italic;
  color: #666;
}

</style>
<p class="breadcrumbs"><a href="http://www.jasondavies.com/">Jason Davies</a>

<h1>Line Simplification</h1>
<p>In cartography, line simplification algorithms are often used to render high-resolution geographic features at an appropriate output resolution.
They can be applied to both polylines and polygons.

<h2>Visvalingam’s Algorithm: Avoiding Intersections</h2>
<p>
Many geometry algorithms require polygons to be <a href="http://en.wikipedia.org/wiki/Simple_polygon">simple</a>, i.e. without self-intersections.
The following map of the Norwegian coastline demonstrates shows occasional intersections generated by Visvalingam’s algorithm, highlighted in red.

<div id="map">
  <div id="controls">
    <p><label for="area">Minimum area:</label>
    <input id="area" type="range" value="4" min="0" max="100" step="1">
    <span id="area-value"></span> px<sup>2</sup>.
    <p><label for="intersect"><input id="intersect" type="checkbox"> Avoid intersections?</label>
  </div>
</div>
<p class="cite">Data: <a href="http://www.statkart.no/Kart/Kartdata/Vektorkart/N2000/">N2000 Kartdata</a> (scale: 1:2,000,000).

<script src="../d3.min.js"></script>
<script src="../maps/topojson.min.js"></script>
<script src="rbush.js"></script>
<script src="visvalingam.js"></script>
<script>(function() {

var width = 720,
    height = 600;

var projection = d3.geo.orthographic()
    .rotate([-8, -60.8, -15])
    .scale(6000)
    .translate([width / 2, height / 2]);

var zoom = d3.behavior.zoom().scaleExtent([1, 0x10]);

var scale,
    translate,
    area;

var filter = d3.geo.transform({
  point: function(x, y, z) {
    if (z >= area) this.stream.point(x * scale + translate[0], y * scale + translate[1]);
  }
});

var path = d3.geo.path().projection(filter);

var svg = d3.select("#map").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(zoom);

d3.json("norway.json", function(error, topology) {
  var absolute = transformAbsolute(topology.transform);
  delete topology.transform;

  var simplify = visvalingam();

  var arcs = topology.arcs = simplify(topology.arcs.map(function(arc) {
    return arc.map(function(d, i) {
      absolute(d, i);
      return projection(d);
    });
  }));

  var arcsIntersect = simplify.intersectSegments(null)(arcs.map(function(arc) {
    return arc.map(function(d) { return d.slice(); });
  }));

  var featurePath = svg.append("path"),
      intersectionsPath = svg.append("path").attr("class", "intersections");

  var areaInput = d3.select("#area").on("input", redraw).on("change", redraw),
      intersectInput = d3.select("#intersect").on("change", redraw);

  svg.call(zoom.on("zoom", redraw).event);

  function redraw() {
    translate = zoom.translate();
    scale = zoom.scale();

    d3.select("#area-value").text(area = +areaInput.property("value"));

    var intersect = d3.select("#intersect").property("checked");
    if (intersect ^ (topology.arcs === arcs)) {
      topology.arcs = intersect ? arcs : arcsIntersect;
      featurePath.datum(topojson.feature(topology, topology.objects.coast));
    }

    var lines = topology.arcs.map(function(arc) {
      return arc.filter(function(d) { return d[2] >= area; });
    });

    intersectionsPath
        .datum({type: "MultiLineString", coordinates: selfIntersections(lines, visvalingam.cartesianIntersect)})
        .attr("d", path);

    featurePath
        .attr("d", path);
  }
});

function transformAbsolute(transform) {
  if (!transform) return noop;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
  };
}

function noop() {}

function selfIntersections(lines, intersectSegments) {
  var tree = rbush(),
      boxes = [];

  for (var j = 0, m = lines.length; j < m; ++j) {
    var line = lines[j],
        n = line.length,
        i = 0,
        p = line[i];
    while (++i < n) boxes.push(bbox(p, p = line[i]));
  }
  tree.load(boxes);

  var intersections = [];
  for (var j = 0, m = boxes.length; j < m; ++j) {
    var box = boxes[j],
        a = box[4],
        b = box[5],
        candidates = tree.search(box);
    for (var i = 0, n = candidates.length; i < n; ++i) {
      var candidate = candidates[i],
          a_ = candidate[4],
          b_ = candidate[5];
      if (!equal(a, a_) &&
          !equal(a, b_) &&
          !equal(b, a_) &&
          !equal(b, b_) &&
          intersectSegments(a, b, a_, b_)) {
        intersections.push([a, b]);
      }
    }
  }

  return intersections;

  function bbox(a, b) {
    var x0 = a[0], y0 = a[1],
        x1 = b[0], y1 = b[1],
        t;
    if (x0 > x1) t = x0, x0 = x1, x1 = t;
    if (y0 > y1) t = y0, y0 = y1, y1 = t;
    return [x0, y0, x1, y1, a, b];
  }

  function equal(a, b) {
    return a[0] === b[0]
        && a[1] === b[1];
  }
}

})()</script>

<p>Intersections can be avoided using a simple modification.
<p>Visvalingam’s algorithm gives each point in a line an importance weighting, so that least important points are removed first.
The importance is commonly derived from the area of the triangle formed by each point and its immediate neighbours.
<p>In the following example, the triangle areas have been replaced with ranks for simplicity, starting with 0 for the smallest area.
<p>On the left, the unmodified Visvalingam algorithm results in an intersection when point 0 is removed.
On the right, the modified algorithm has promoted this point to the next-largest effective area, hence two points have rank 0, and the intersection is avoided when they are both removed at once.

<div id="chart">
  <div class="simplify"><h3>Unmodified Visvalingam</h3></div>
  <div class="simplify"><h3>Modified Visvalingam</h3></div>
</div>

<script>(function() {

var width = 360,
    height = 80;

var path = d3.geo.path().projection(null);

var points = [
  [ 10, 100],
  [120, 110],
  [100,  90],
  [100,  10],
  [125,  10],
  [105,  80],
  [300,  80],
  [300,  10]
];

points = [[10,60,3],[135,68,0],[94,48,0],[126,31,1],[280,19,1],[117,48],[300,40],[301,10]];

var div = d3.select("#chart").selectAll(".simplify")
    .data([{}, {intersectSegments: visvalingam.cartesianIntersect}])
    .each(redraw);

function redraw(d) {
  var simplify = transform(visvalingam().intersectSegments(d.intersectSegments));
  simplify({type: "LineString", coordinates: points});

  var areas = d3.set(points.map(function(d) { return d[2]; }))
      .values()
      .map(Number)
      .sort(function(a, b) { return a - b; });

  var areaScale = d3.scale.ordinal().domain(areas).range(d3.range(areas.length));

  points.forEach(function(d) { d[2] = areaScale(d[2]); });

  var divStep = d3.select(this).selectAll("div")
      .data(d3.range(areas.length).map(function(i) {
        return points.filter(function(d) { return d[2] >= i; });
      }));

  var svgEnter = divStep.enter().append("div").append("svg")
      .attr("width", width)
      .attr("height", height);

  svgEnter.append("path");

  var svg = divStep.select("svg");

  svg.select("path")
      .datum(function(d) { return {type: "LineString", coordinates: d}; })
      .attr("d", path);

  var g = svg.selectAll("g").data(function(d) { return d; });
  var gEnter = g.enter().append("g")
      .call(d3.behavior.drag()
        .origin(function(d) { return {x: d[0], y: d[1]}; })
        .on("drag", function(d) {
          d[0] = Math.max(7, Math.min(width - 7, d3.event.x)),
          d[1] = Math.max(7, Math.min(height - 7, d3.event.y));
          div.each(redraw);
        }));
  g.attr("transform", function(d) { return "translate(" + d[0] + "," + d[1] + ")"; });
  g.exit().remove();

  gEnter.append("circle").attr("r", 6.5);
  gEnter.append("text").attr("text-anchor", "middle").attr("dy", ".4em");
  g.select("text").text(function(d) { return d[2]; });

  divStep.exit().remove();
}

// Simple in-place transformation on [Multi]{Polygon,LineString}.
function transform(multiLine) {
  var type = {
    FeatureCollection: function(collection) {
      var features = collection.features;
      for (var i = 0, n = features.length; i < n; ++i) feature(features[i]);
    },
    Feature: function(feature_) { feature(feature_.geometry); },
    GeometryCollection: function(collection) {
      var geometries = collection.geometries;
      for (var i = 0, n = geometries.length; i < n; ++i) feature(geometries[i]);
    },
    MultiPolygon: function(multiPolygon) {
      var coordinates = multiPolygon.coordinates;
      for (var i = 0, n = coordinates.length; i < n; ++i) multiLine(coordinates[i]);
    },
    Polygon: function(polygon) {
      multiLine(polygon.coordinates);
    },
    MultiLineString: function(multiLineString) {
      multiLine(multiLineString.coordinates);
    },
    LineString: function(lineString) {
      multiLine([lineString.coordinates]);
    },
    MultiPoint: noop,
    Point: noop
  };

  return feature;

  function feature(feature) {
    type[feature.type](feature);
    return feature;
  };
}

function noop() {}

})()</script>

<h2 id="pseudocode">Explanation</h2>
<p>We begin by assuming that there are no intersections between any segments.
Each time we remove a point from the heap, we ensure that the assumption still holds.
It’s somewhat easier to explain via the pseudocode below, with <span class="modified">modifications</span> to the standard Visvalingam algorithm highlighted:

<pre><code class="javascript">// points is a doubly linked list
simplify(points)
  heap = minHeap(compareArea)
  maxArea = 0
<span class="modified">  intersecting = []</span>

  for (point in points)
    point.area = area(point)
    heap.add(point)

  while (point = heap.pop())
    if (point.area < maxArea) point.area = maxArea
    else maxArea = point.area

<span class="modified">    // Check that the new segment doesn’t intersect with
    // any existing segments, except for the point’s
    // immediate neighbours.
    if (intersect(heap, point.previous, point.next))
      intersecting.push(point)
      continue

    // Reattempt to process points that previously would
    // have caused intersections when removed.
    while (i = intersecting.pop()) heap.push(i)</span>

    remove(point) // remove from doubly linked list
    update(point.previous, heap)
    update(point.next, heap)

update(point, heap)
  point.area = area(point)
  heap.update(point)
</code></pre>

<h2>Performance</h2>
<p>Checking for intersections between the new segment and virtually all existing segments quickly becomes impractical for non-trivial numbers of segments.
<p>The number of intersection tests can be reduced drastically using a spatial index, e.g. an <a href="http://en.wikipedia.org/wiki/R*_tree">R*-tree</a> is used in the current implementation (<a href="https://github.com/mourner/rbush">RBush</a>) with excellent results.

<h2>Future Work</h2>

<p>The current implementation is 2D-only, but I’d like to add support for <a href="../maps/intersect/">spherical arc intersections</a>.
This could potentially end up as part of <a href="https://github.com/mbostock/topojson">TopoJSON</a> so that problematic self-intersecting polygons are avoided when drawn with <a href="http://d3js.org">D3</a>.

<h2>Further Reading</h2>
<ul>
  <li>Mike Bostock has written a nice <a href="http://bost.ocks.org/mike/simplify/">illustrated explanation</a> of how Visvalingam’s algorithm works.
  <li><a href="http://dx.doi.org/10.1590/S0104-65002004000100006">The Douglas–Peucker algorithm: sufficiency conditions for non-self-intersections</a>
  <li><a href="http://doi.ieeecomputersociety.org/10.1109/MCG.2006.85">MapShaper.org: A Map Generalization Web Service</a>
</ul>
<script src="../highlight.min.js"></script>
